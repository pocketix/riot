# ----- SD types and instances -----

enum SDParameterType {
  STRING
  NUMBER
  BOOLEAN
}

type SDParameter {
  id: ID!
  denotation: String!
  type: SDParameterType!
}

type SDType {
  id: ID!
  denotation: String!
  parameters: [SDParameter!]!
}

input SDParameterInput {
  denotation: String!
  type: SDParameterType!
}

input SDTypeInput {
  denotation: String!
  parameters: [SDParameterInput!]!
}

type SDInstance {
  id: ID!
  uid: String!
  confirmedByUser: Boolean!
  userIdentifier: String!
  type: SDType!
}

input SDInstanceUpdateInput {
  userIdentifier: String
  confirmedByUser: Boolean
}

# ----- KPI definitions and nodes -----

enum SDInstanceMode {
  ALL
  SELECTED
}

type KPIDefinition {
  id: ID!
  sdTypeID: ID!
  sdTypeSpecification: String!
  userIdentifier: String!
  nodes: [KPINode!]!
  sdInstanceMode: SDInstanceMode!
  selectedSDInstanceUIDs: [String!]!
}

interface KPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
}

enum LogicalOperationType {
  AND
  OR
  NOR
}

type LogicalOperationKPINode implements KPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  type: LogicalOperationType!
}

interface AtomKPINode implements KPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
}

type StringEQAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  stringReferenceValue: String!
}

type BooleanEQAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  booleanReferenceValue: Boolean!
}

type NumericEQAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  numericReferenceValue: Float!
}

type NumericGTAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  numericReferenceValue: Float!
}

type NumericGEQAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  numericReferenceValue: Float!
}

type NumericLTAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  numericReferenceValue: Float!
}

type NumericLEQAtomKPINode implements KPINode & AtomKPINode {
  id: ID!
  parentNodeID: ID
  nodeType: KPINodeType!
  sdParameterID: ID!
  sdParameterSpecification: String!
  numericReferenceValue: Float!
}

input KPIDefinitionInput {
  sdTypeID: ID!
  sdTypeSpecification: String!
  userIdentifier: String!
  nodes: [KPINodeInput!]!
  sdInstanceMode: SDInstanceMode!
  selectedSDInstanceUIDs: [String!]!
}

enum KPINodeType {
  StringEQAtom,
  BooleanEQAtom,
  NumericEQAtom,
  NumericGTAtom,
  NumericGEQAtom,
  NumericLTAtom,
  NumericLEQAtom,
  LogicalOperation
}

input KPINodeInput {
  type: KPINodeType!
  id: ID!
  parentNodeID: ID
  sdParameterID: ID
  sdParameterSpecification: String
  stringReferenceValue: String
  booleanReferenceValue: Boolean
  numericReferenceValue: Float
  logicalOperationType: LogicalOperationType
}

# ----- KPI fulfillment check results -----

type KPIFulfillmentCheckResult {
  kpiDefinitionID: ID!
  sdInstanceID: ID!
  fulfilled: Boolean!
}

type KPIFulfillmentCheckResultTuple {
  kpiFulfillmentCheckResults: [KPIFulfillmentCheckResult!]!
}

# ----- SD instance groups -----

type SDInstanceGroup {
  id: ID!
  userIdentifier: String!
  sdInstanceIDs: [ID!]!
}

input SDInstanceGroupInput {
  userIdentifier: String!
  sdInstanceIDs: [ID!]!
}

# ----- Statistics

scalar Date

type SimpleSensors {
  sensors: [String!]!
}

type SensorsWithFields {
  sensors: [SensorField!]!
}

type SensorField {
  key: String!
  values: [String!]!
}

enum StatisticsOperation {
  MEAN
  MIN
  MAX
  FIRST
  SUM
  LAST
  NONE
  COUNT
  INTEGRAL
  MEDIAN
  MODE
  QUANTILE
  REDUCE
  SKEW
  SPREAD
  STDDEV
  TIMEWEIGHTEDAVG
}

"""
Data used for querying the selected bucket
"""
input StatisticsInput {
  """
  Sensors to be queried
  """
  sensors: SensorsInput!
  """
  Start of the querying window
  """
  from: Date
  """
  End of the querying window
  """
  to: Date
  """
  Amount of minutes to aggregate by
  For example if the queried range has 1 hour and aggregateMinutes is set to 10 the aggregation will result in 6 points
  """
  aggregateMinutes: Int
  """
  Timezone override default UTC.
  For more details why and how this affects queries see: https://www.influxdata.com/blog/time-zones-in-flux/.
  In most cases you can ignore this and some edge aggregations can be influenced.
  If you need a precise result or the aggregation uses high amount of minutes provide the target time zone.
  """
  timezone: String
  """
  Aggregation operator to use, if needed
  """
  operation: StatisticsOperation
}

"""
Sensors to be queried
"""
input SensorsInput {
  """
  Simple definition, returns all available sensor fields
  """
  simpleSensors: [String]
  """
  Return only the requested sensor fields
  """
  sensorsWithFields: [SensorFieldInput]
}

"""
Return only the requested sensor fields
"""
input SensorFieldInput {
  key: String!
  fields: [String!]!
}

scalar StatisticsParameterValue

type StatisticsField {
  key: String!
  value: StatisticsParameterValue!
}

type OutputData {
  time: Date!
  deviceId: String!
  deviceType: String
  data: StatisticsField!
}

input StatisticsFieldInput {
  key: String!
  value: StatisticsParameterValue!
}

input InputData {
  time: Date!
  deviceId: String!
  deviceType: String
  data: StatisticsFieldInput!
}

# ----- Queries, mutations and subscriptions -----

type Query {
  sdType(id: ID!): SDType!
  sdTypes: [SDType!]!
  sdInstances: [SDInstance!]!
  kpiDefinition(id: ID!): KPIDefinition!
  kpiDefinitions: [KPIDefinition!]!
  kpiFulfillmentCheckResults: [KPIFulfillmentCheckResult!]!
  sdInstanceGroup(id: ID!): SDInstanceGroup!
  sdInstanceGroups: [SDInstanceGroup!]!
  statisticsQuery(request: StatisticsInput!): [OutputData!]!
}

type Mutation {
  createSDType(input: SDTypeInput!): SDType!
  deleteSDType(id: ID!): Boolean!
  updateSDInstance(id: ID!, input: SDInstanceUpdateInput!): SDInstance!
  createKPIDefinition(input: KPIDefinitionInput!): KPIDefinition!
  updateKPIDefinition(id: ID!, input: KPIDefinitionInput!): KPIDefinition!
  deleteKPIDefinition(id: ID!): Boolean!
  createSDInstanceGroup(input: SDInstanceGroupInput!): SDInstanceGroup!
  updateSDInstanceGroup(id: ID!, input: SDInstanceGroupInput!): SDInstanceGroup!
  deleteSDInstanceGroup(id: ID!): Boolean!
  statisticsMutate(inputData: InputData!): Boolean!
}

type Subscription {
  onSDInstanceRegistered: SDInstance!
  onKPIFulfillmentChecked: KPIFulfillmentCheckResultTuple!
}
